#

import os
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy.signal import savgol_filter
from scipy.special import erf

# ========= Input: two-column ESF file (pos_mm, intensity_norm) =========
esf_path = r'D:\Summer research project\week12\MTF\NA3\4mm_esf_mm.txt'  # path to ESF (mm) file
name = '4mm'                                                            # label for outputs

data = np.loadtxt(esf_path)
pos_mm_full = data[:, 0]  # position in mm
esf_full    = data[:, 1]  # normalized intensity

# Optional: sort by position in case the file is unordered
order = np.argsort(pos_mm_full)
pos_mm_full = pos_mm_full[order]
esf_full    = esf_full[order]

# ========= Crop in mm (set a window on the mm axis) =========
# If pixel pitch = 6.45 µm => 6.45e-3 mm; if object space has magnification M, use 6.45e-3 / M.
mm_per_px = 6.45e-3

# Example window equivalent to pixel indices [350, 450] converted to mm
lo = 350 * mm_per_px
hi = 450 * mm_per_px
crop_mm = (lo, hi)

# Boolean mask crop (inclusive)
mask   = (pos_mm_full >= crop_mm[0]) & (pos_mm_full <= crop_mm[1])
pos_mm = pos_mm_full[mask]
esf    = esf_full[mask]

# ---------- Preprocess ESF ----------
# Normalize to [0,1]
esf = (esf - esf.min()) / (esf.max() - esf.min())

# Savitzky–Golay smoothing (ensure odd window and not longer than data)
win = min(9, len(esf) if len(esf) % 2 == 1 else len(esf) - 1)
if win >= 5:  # skip if the series is too short
    esf = savgol_filter(esf, win, 2)

# ---------- Boone ESF model (domain in mm) ----------
def boone(s_mm, a0, a1, a2, s0, sigma, beta):
    erf_part = 0.5 + 0.5 * erf((s_mm - s0) / sigma)
    tail     = a2 * np.exp(-beta * (s_mm - s0))
    return a0 + a1 * erf_part + tail

# Initial guesses on the mm axis
idx_half = np.argmax(esf < 0.5)  # first index where ESF < 0.5
s0_guess = pos_mm[idx_half] if np.any(esf < 0.5) else 0.5 * (pos_mm.min() + pos_mm.max())
sigma_guess = 0.2 * (pos_mm.max() - pos_mm.min())
p0 = [0.05, 0.9, 0.01, s0_guess, max(sigma_guess, 1e-4), 0.01]

# Fit
popt, _ = curve_fit(boone, pos_mm, esf, p0=p0, maxfev=8000)
a0, a1, a2, s0, sigma, beta = popt
print('Fit params:', popt)

# ---------- Goodness of fit ----------
resid = esf - boone(pos_mm, *popt)
r2 = 1 - np.sum(resid**2) / np.sum((esf - esf.mean())**2)
print(f'R² = {r2:.4f}')

# ---------- LSF (analytic & numeric) on mm axis ----------
gauss = a1 / (np.sqrt(np.pi) * sigma) * np.exp(-(pos_mm - s0)**2 / sigma**2)
tail  = -a2 * beta * np.exp(-beta * (pos_mm - s0))
lsf_a = gauss + tail
lsf_a /= (lsf_a.max() + 1e-12)

# Numeric derivative using physical step (mm)
lsf_n = np.gradient(esf, pos_mm)
lsf_n /= (lsf_n.max() + 1e-12)

# ---------- MTF (analytic & numeric) ----------
# Spatial frequency axis in cycles/mm
ds = float(np.median(np.diff(pos_mm)))        # sampling step (mm)
freq  = np.fft.rfftfreq(len(lsf_a), d=ds)     # cycles/mm
mtf_a = np.abs(np.fft.rfft(lsf_a)); mtf_a /= mtf_a[0]
mtf_n = np.abs(np.fft.rfft(lsf_n)); mtf_n /= mtf_n[0]

# ---------- Save results (ESF/LSF as two columns; MTF as CSV) ----------
outdir = os.path.dirname(esf_path)
base   = f'{name}_boone_mm'

path_esf = os.path.join(outdir, f'{base}_esf.txt')
path_lsf = os.path.join(outdir, f'{base}_lsf.txt')
path_mtf = os.path.join(outdir, f'{base}_mtf.csv')

np.savetxt(path_esf, np.column_stack([pos_mm, boone(pos_mm, *popt)]),
           fmt='%.6f', header='pos_mm\tESF_fit', comments='')
np.savetxt(path_lsf, np.column_stack([pos_mm, lsf_a]),
           fmt='%.6f', header='pos_mm\tLSF_norm', comments='')
np.savetxt(path_mtf, np.column_stack([freq, mtf_a]),
           fmt='%.6f', delimiter=',', header='freq_cyc_per_mm,MTF', comments='')

print("Saved:")
print(" ", path_esf)
print(" ", path_lsf)
print(" ", path_mtf)

# ---------- Plots (mm / cycles/mm) ----------
fig, axs = plt.subplots(1, 3, figsize=(12, 3.6))

axs[0].plot(pos_mm, esf, 'o', ms=3, label='raw')
axs[0].plot(pos_mm, boone(pos_mm, *popt), 'r-', label='Boone fit')
axs[0].set_title('ESF (mm)'); axs[0].legend(); axs[0].grid(alpha=.3)
axs[0].set_xlabel('Position (mm)'); axs[0].set_ylabel('Intensity (norm)')

axs[1].plot(pos_mm, lsf_a, 'r-', label='analytic')
axs[1].plot(pos_mm, lsf_n, 'k--', label='numeric')
axs[1].set_title('LSF (mm)'); axs[1].legend(); axs[1].grid(alpha=.3)
axs[1].set_xlabel('Position (mm)'); axs[1].set_ylabel('LSF (norm)')

axs[2].plot(freq, mtf_a, 'r-', label='analytic')
axs[2].plot(freq, mtf_n, 'ko', ms=2, label='numeric')
axs[2].set_xlim(0, freq.max()); axs[2].set_ylim(0, 1.05)
axs[2].set_title('MTF'); axs[2].legend(); axs[2].grid(alpha=.3)
axs[2].set_xlabel('Spatial frequency (cycles/mm)'); axs[2].set_ylabel('MTF')

plt.tight_layout(); plt.show()
